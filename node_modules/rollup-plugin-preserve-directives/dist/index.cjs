"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default,
  preserveDirectives: () => preserveDirectives
});
module.exports = __toCommonJS(src_exports);
var import_magic_string = __toESM(require("magic-string"), 1);
var import_pluginutils = require("@rollup/pluginutils");
function preserveDirectives({
  suppressPreserveModulesWarning,
  include = [],
  exclude = []
} = {}) {
  const excludePatterns = ["**/*.css", ...exclude];
  const filter = (0, import_pluginutils.createFilter)(include, excludePatterns);
  return {
    name: "preserve-directives",
    // Capture directives metadata during the transform phase
    transform(code, id) {
      var _a;
      if (!filter(id))
        return;
      const ast = this.parse(code);
      if (ast.type === "Program" && ast.body) {
        const directives = [];
        let i = 0;
        const filteredBody = ast.body.filter(Boolean);
        while (((_a = filteredBody[i]) == null ? void 0 : _a.type) === "ExpressionStatement") {
          const node = filteredBody[i];
          if ("directive" in node) {
            directives.push(node.directive);
          }
          i += 1;
        }
        if (directives.length > 0) {
          return {
            code,
            ast,
            map: null,
            meta: { preserveDirectives: directives }
          };
        }
      }
      return { code, ast, map: null };
    },
    // We check if this chunk has a module with extracted directives
    // and add that to the top.
    // Because we only run this when preserveModules: true there should
    // only be one module per chunk.
    // Banners will already have been inserted here, so directives always
    // ends up at the absolute top.
    renderChunk: {
      order: "post",
      handler(code, chunk, options) {
        var _a, _b;
        if (!options.preserveModules) {
          if (!suppressPreserveModulesWarning) {
            this.warn(
              "This plugin only works with the option preserveModules: true, if you want to add directives to the top of a bundled build, add it in a banner."
            );
          }
          return void 0;
        }
        let chunkHasDirectives = false;
        if ("modules" in chunk) {
          for (const moduleId of Object.keys(chunk.modules)) {
            const directives = (_b = (_a = this.getModuleInfo(moduleId)) == null ? void 0 : _a.meta) == null ? void 0 : _b.preserveDirectives;
            if (directives) {
              chunkHasDirectives = directives;
            }
          }
          if (chunkHasDirectives) {
            const directiveStrings = chunkHasDirectives.map((directive) => `"${directive}"`).join(";\n");
            const s = new import_magic_string.default(code);
            s.prepend(`${directiveStrings};
`);
            const srcMap = s.generateMap({ includeContent: true });
            return { code: s.toString(), map: srcMap };
          }
        }
        return null;
      }
    }
  };
}
var src_default = preserveDirectives;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  preserveDirectives
});
